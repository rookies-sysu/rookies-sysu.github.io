<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <title>Posts - Tiny Hippo 团队博客</title>
  
  <meta name="description" content="">
  <meta name="author" content="">
  
  
  <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet">
  <link href="/css/style.css" rel="stylesheet">
  
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
  <link rel="icon" href="/img/favicon.ico">
  
  <meta name="generator" content="Hugo 0.37.1">
  
  <link rel="alternate" type="application/atom+xml" href="/index.xml" title="Tiny Hippo 团队博客">
</head>
<body class="list">
  <header class="header">
    
    <p class="title"><a href="/"><span>🍱</span>Tiny Hippo 团队博客</a></p>
    
    <button class="menu-toggle" type="button"></button>
    <nav class="menu">
      <ul>
        
        
      </ul>
    </nav>
  </header>
  <main class="main">


<header class="list-header">
  <h1 class="list-title">Posts</h1>
  
</header>







<article class="post post-entry">
  <header class="post-header">
    
    <h2 class="post-title">Docker 构建镜像入门，以 Python Flask 为例</h2>
  </header>
  <p class="post-summary">[TOC]
 原文链接：Docker 构建镜像入门，以 Python Flask 为例
为了完成中山大学系统分析与设计课程，在项目作业仓库中重新发布一次技术博客
个人信息：罗剑杰 15331229 数字媒体技术
 Docker 构建镜像入门，以 Python Flask 为例  实验环境： Ubuntu 16.04 LTS
本文介绍如何自行构建一个封装了 python flask 的 docker 镜像，并且运行它的一个容器。
 什么是Docker Docker是一个操作系统容器管理工具，通过将应用打包到操作系统容器里面，从而让你能轻松管理和部署应用。
容器 vs 虚拟机 容器可能不如虚拟机一样为人所熟知，但是它们是另外的一种提供操作系统虚拟化的方法。然而，他们与标准的虚拟机有很大的差异。
标准的虚拟机通常包含一个完整的操作系统，OS软件包，最后包含一两个应用。它是通过一个向虚拟机提供了硬件虚拟化的Hypervisor来实现的，允许单个服务器运行很多独立的被当做虚拟游客（virtual guest）的操作系统。
而容器与虚拟机的类似之处在于它们允许单个服务器运行多个操作环境（operating environment），然而这些环境不却是完整的操作系统。容器通常只包含必要的OS软件包和应用。他们通常不包含一个完整的操作系统或者硬件虚拟化。这也意味着比之虚拟机，容器的额外开销（overhead）更小。
 容器和虚拟机通常被视为不能共生的技术，然而这通常是一个误解。虚拟机面向物理服务器，提供可以能与其他虚拟机一起共享这些物理资源的，功能完善的操作环境。容器通常是用来通过对单一主机的一个进程进行隔离，来保证被隔离的进程无法与处于同一个系统的其他进程进行互动。实际上，比起完全的虚拟机，容器与BSD的Jail，chroot的进程更加类似。
 Docker 自身并不是一个容器的运行时环境。 Docker 提供的是一种容器管理，打包和部署的方法。尽管这种类型的功能已经某一种程度地存在于虚拟机中，但在传统上，它们并不是为了绝大多数的容器方案而生的，而那些已经存在的，却又不如 Docker 一样容易使用且功能完善。
安装 Docker sudo apt install docker sudo apt install docker.io  安装成功后，可以使用 docker ps 命令来检测是否正确安装：
longj@longj-Daydream:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES  有时候会出现下面报错：...</p>
  <footer class="post-footer">
    <p class="post-meta">2018.4.15</p>
  </footer>
  <a class="post-link" href="http://rookies-sysu.github.io/posts/docker/"></a>
</article>




<article class="post post-entry">
  <header class="post-header">
    
    <h2 class="post-title">Flask 学习笔记</h2>
  </header>
  <p class="post-summary">##1.Flask的配置
使用virtualenv将应用隔离在一个虚拟环境中，该虚拟环境包含了应用依赖的文件的文件夹，在linux系统下安装virtualenv的操作：
$ pip install virtualenv  随后利用virtualenv创建虚拟环境，文件夹名为venv：
$ virtualenv venv New python executable in venv/bin/python Installing setuptools, pip...done.  通过运行该文件夹下的bin/activate脚本来激活虚拟环境
$ source ~/venv/bin/activate  此时虚拟环境已运行，在该环境下安装相关的依赖包即可
（venv）$ pip install flask  这样Flask的基本配置就完成了，后面在需要时同理可以添加其它相关的依赖包
##2.一个入门级别的应用
from flask import Flask app = Flask(__name__) @app.route(&#39;/&#39;) def hello_world(): return &#39;Hello World!&#39; if __name__ == &#39;__main__&#39;: app.run()  将该代码保存为app.py,然后在虚拟环境下用python解释器运行
（venv）$ python app.py * Running on http://127.0.0.1:5000/  分析过程：
1.导入Flask类，该类实例作为WSGI应用程序。 2.创建该类实例app，当为单一模块时使用__name__ 3.使用route()装饰器告诉Flask什么样的URL可以触发函数 4.定义函数在生成URL时采用，返回需要显示在用户浏览器的信息 5.用run()函数在本地服务器上运行，其中 if __name__ == &#39;__main__&#39;: 确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行  ...</p>
  <footer class="post-footer">
    <p class="post-meta">2018.4.15</p>
  </footer>
  <a class="post-link" href="http://rookies-sysu.github.io/posts/flask/"></a>
</article>




<article class="post post-entry">
  <header class="post-header">
    
    <h2 class="post-title">项目管理经验分享（一）</h2>
  </header>
  <p class="post-summary">作为团队的 PM，要让整个团队 run 起来不是一件容易的事情。团队集结完毕后，需要立刻熟悉团队成员的个性，并且要尽快进入团队协作的状态。同时，对于一个团队项目，需要的技术栈，对应技术栈需要分配的成员也是在不断探索，所以在这里记录下当 PM 的一些体会。
任务安排 我们团队有四个男生，两个女生，还有一名外援。外援由于一些特殊原因安排他去做一个相对独立的部分，所以接下来不会仔细介绍。其余团队成员我会用他们的 Github ID 或者 Github ID 简称来代替。
在第一次会议中，大家介绍了自己的掌握的知识栈了。基本所有人都只是会一些前端技术栈，除了 - longjj 会一些运维和部署的知识 - Ecr23 懂一点产品和设计的知识 - Aruru 不会前端
所以有了 Dashboard - Team Profile 里面的任务分配
其实本来我想的是每周开一次会，队内 longjj 建议每天都要记录KANBAN，所以我们团队整体迭代速度很快。任务安排下去后，前端领导人 BeAShaper 很快就做出了第一版的模型。相比之下由于后台没有太多需求，所以进展要还慢一些。在他们两位的带领下，我们快速做出了第一版原型，第一次迭代在清明节基本结束
但是清明节后，由于团队几位核心成员去面试、比赛，剩下成员动力不足，所以整体停滞了两周到最近。总结一下，任务安排方面，做的好的： 1. PM 一定要选取适合的分团队领导，这样由小队长带领的团队推动迅速 2. 项目早期选择快速做出原型有利于团队内部互相磨合。我们快速的做出了第一个可运行的原型，同时大家也很熟悉了对方的开发能力和个人特点。至少对于 PM 来说在接下来安排任务的时候会更合理 3. 团队内最好半周见一次面。我们现在见面的频率比较适宜，周三小会议，周日大会议，快速跟进，小团队非常实用！
做的不太好的： 1. 每天记录工作内容有点不现实，大家积极性不是很高，类似的 administration work 比较消耗大家的精力 2. 周期性的迭代应当有明确的目标。第一次迭代里面后台部分我觉得不是特别理想，因为目标不是很明确，结果就是后台除了 longjj 之外普遍没有做太多的工作，浪费了时间 3. 因为中途要面试和比赛，两位小组长也有自己的事情要做，所以整体工作停了半个月。这个是预期之外的，对大家整体积极性有一定的打击，以后要避免！
分项进度 前端 前端用了很短时间就确定采用小程序作为技术栈，我觉得这个是非常明智的选择。小程序开发上手实在很快，而且可以直接在真机调试，效果比较直接。同时学习成本比较低，以后在做小项目的时候，如果是移动端，我会比较优先推荐小程序
后台 后台组长选择 flask 开发，由于参与不是很多，所以不细讲
UI设计 这次我 ECer23 同时也是设计师。虽然这么做不正规但是小团队也没办法了。设计工具采用的是 modao，因为这货天天给我发广告邮件 🙂。不过的确挺好用。...</p>
  <footer class="post-footer">
    <p class="post-meta">2018.4.15</p>
  </footer>
  <a class="post-link" href="http://rookies-sysu.github.io/posts/management/"></a>
</article>




<article class="post post-entry">
  <header class="post-header">
    
    <h2 class="post-title">About</h2>
  </header>
  <p class="post-summary"> 小河马点餐是一个微信点餐小程序。它以微信为入口，使用手机进行点餐。小河马点餐相比传统点餐服务，除了支持传统的浏览、下单、付款的传统服务之外，还有以下几个特点：
 支持多人同时点餐 更加人性化的UI设计 and more  Team profile 目前，小河马团队共6人，他们是：[Ecr23 - 彭高]()、[longjj - 罗剑杰]()、[BeAShaper - 马晓鹤]()、[Arurururu - 彭彩莹]()、[Yunglinjy - 林景仰]()、[liuzt - 刘钟涛]()。目前，我们的分工如下
 项目经理: Ecer23* 前端团队: BeAShaper*, Arurururu, Ecer23 后台团队: longjj*, Yunglinjy, liuzht  名字里带有 * 表示他/她是分项负责人
Investigation 🦕项目流程图传送门，密码是 9PsW
Vision Product Backlog Requirement specification Design Development guidelines Documentation Links  迭代文档 会议记录 需求分析  ...</p>
  <footer class="post-footer">
    <p class="post-meta">2018.4.12</p>
  </footer>
  <a class="post-link" href="http://rookies-sysu.github.io/posts/about/"></a>
</article>



</main>
<footer class="footer">
  <span>&copy; 2017-2018 Tiny Hippo 团队博客 🎉</span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" target="_blank">Hugo❤️️</a></span>
  <span>&middot;</span>
  <span>Designed by <a href="http://21beats.com/" target="_blank">️21beats⚡️</a></span>
</footer>
<script src="https://cdn.bootcss.com/instantclick/3.0.1/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js" data-no-instant></script>
<script data-no-instant>
  hljs.initHighlightingOnLoad();
  menuToggle();
  InstantClick.on('change', function() {
    var blocks = document.querySelectorAll('pre code');
    for (var i = 0; i < blocks.length; i++) {
      hljs.highlightBlock(blocks[i]);
    }
    menuToggle();
  });
  function menuToggle() {
    var $toggle = document.querySelector('.menu-toggle');
    if (!$toggle.offsetParent) {
      return;
    }
    var $body = document.querySelector('body');
    $toggle.addEventListener('click', function() {
      $body.classList.toggle('noscroll');
    }, false);
  }
</script>
</body>
</html>
